<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <LINK REL="stylesheet" TYPE="text/css" HREF="doc.css">
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.71">
 <TITLE>Foenix F256jr-specific information for cc65</TITLE>
</HEAD>
<BODY>
<H1>Foenix F256jr-specific information for cc65</H1>

<H2>
<A HREF="mailto:micahbly@gmail.com">Micah Bly</A><BR>
<HR>
<EM>An overview over the Foenix C256jr runtime system as it is implemented for the cc65 C
compiler.</EM>
<HR>
<P>
<H2><A NAME="toc1">1.</A> <A HREF="f256jr.html#s1">Overview</A></H2>

<P>
<H2><A NAME="toc2">2.</A> <A HREF="f256jr.html#s2">Binary format</A></H2>

<P>
<H2><A NAME="toc3">3.</A> <A HREF="f256jr.html#s3">Memory layout</A></H2>

<P>
<H2><A NAME="toc4">4.</A> <A HREF="f256jr.html#s4">Platform-specific header files</A></H2>

<UL>
<LI><A NAME="toc4.1">4.1</A> <A HREF="f256jr.html#ss4.1">F256jr-specific functions</A>
<LI><A NAME="toc4.2">4.2</A> <A HREF="f256jr.html#ss4.2">F256jr-specific accelerator functions</A>
<LI><A NAME="toc4.3">4.3</A> <A HREF="f256jr.html#ss4.3">Foenix-specific functions</A>
<LI><A NAME="toc4.4">4.4</A> <A HREF="f256jr.html#ss4.4">Foenix specific CPU functions</A>
<LI><A NAME="toc4.5">4.5</A> <A HREF="f256jr.html#ss4.5">Hardware access</A>
</UL>
<P>
<H2><A NAME="toc5">5.</A> <A HREF="f256jr.html#s5">Loadable drivers</A></H2>

<UL>
<LI><A NAME="toc5.1">5.1</A> <A HREF="f256jr.html#ss5.1">Graphics drivers</A>
<LI><A NAME="toc5.2">5.2</A> <A HREF="f256jr.html#ss5.2">Extended memory drivers</A>
<LI><A NAME="toc5.3">5.3</A> <A HREF="f256jr.html#ss5.3">Joystick drivers</A>
<LI><A NAME="toc5.4">5.4</A> <A HREF="f256jr.html#ss5.4">Mouse drivers</A>
<LI><A NAME="toc5.5">5.5</A> <A HREF="f256jr.html#ss5.5">RS232 device drivers</A>
</UL>
<P>
<H2><A NAME="toc6">6.</A> <A HREF="f256jr.html#s6">Limitations</A></H2>

<UL>
<LI><A NAME="toc6.1">6.1</A> <A HREF="f256jr.html#ss6.1">Realtime clock</A>
</UL>
<P>
<H2><A NAME="toc7">7.</A> <A HREF="f256jr.html#s7">Other hints</A></H2>

<UL>
<LI><A NAME="toc7.1">7.1</A> <A HREF="f256jr.html#ss7.1">Passing arguments to the program</A>
<LI><A NAME="toc7.2">7.2</A> <A HREF="f256jr.html#ss7.2">Program return code</A>
<LI><A NAME="toc7.3">7.3</A> <A HREF="f256jr.html#ss7.3">Interrupts</A>
</UL>
<P>
<H2><A NAME="toc8">8.</A> <A HREF="f256jr.html#s8">License</A></H2>


<HR>
<H2><A NAME="s1">1.</A> <A HREF="#toc1">Overview</A></H2>


<P>This file contains an overview of the F256jr runtime system as provided by this project, for the
cc65 C compiler. The F256jr library is not an official part of cc65 and may have errors, bugs, and generally suck. This file describes the memory layout, F256jr-specific header files,
available drivers, and any pitfalls specific to that platform.</P>
<P>Two runtime libraries are provided. If you are not planning to use any of the Foenix microkernel functionality, use the "f256jr.lib" runtime. It provides only basic initialization functionality. If you will be using microkernel functions, use the "f256jr_with_kernel.lib" runtime (NOTE: this is currently provided directly by Gadget, the developer of the microkernel). </P>
<P>Please note that there are currently no F256jr-specific functions, although that may change in the near future. </P>


<H2><A NAME="s2">2.</A> <A HREF="#toc2">Binary format</A></H2>


<P>The standard binary output format generated by the linker for the F256jr target
is a machine language program. As of January 4, 2023, the only way to load it onto the F256jr is via the USB debug port. Having loaded it, you can execute it either via SuperBASIC or DOS. In SuperBASIC, type "call $400" (or whereever your startup code is). If you are in Foenix DOS, type "exec $400" (or your startup address). As soon as SD card support is ready on the Foenix, we will describe how to load and start cc65 programs from within SuperBASIC and DOS. </P>


<H2><A NAME="s3">3.</A> <A HREF="#toc3">Memory layout</A></H2>


<P>cc65 generated programs with the default setup assume you will have a standard MMU configuration (that you set yourself) where 65C02 banks 0-5 are matched to physical banks 0-5, with bank 6 (IO) not used for MAIN, and bank 7 (kernel) not used at all. If you are using an overlay configuration, cc65 expects all overlays to be 8K or less, and reside in bank 05 ($a000-$bffff).</p>
<P>If using overlays, the setup gives a usable memory range of $0400 - $9fff: about 39k continguous for MAIN and the C stack. If you do not use overlays, MAIN extends from $0400 - $bfff, about 47k.</P>
<P>Special locations:</P>
<P>
<DL>
<DT><B>Zero Page</B><DD>
<P>The F256 system reserves zero page addresses $00 - $0f. The microkernel reserves $f0-$ff. By default, cc65 is set up to use $40 - $ef for itself and your code. cc65 will only use about 20 bytes of ZP space on its own. </P>

<DT><B>Stack</B><DD>
<P>The C runtime stack is located at $9FFF (if using overlays) or $BFFF (if not using overlays), and growing downwards.</P>

<DT><B>Heap</B><DD>
<P>The C heap is located at the end of the program, and grows towards the C
runtime stack.</P>

</DL>
</P>




<H2><A NAME="s4">4.</A> <A HREF="#toc4">Platform-specific header files</A></H2>


<P>Programs containing F256jr-specific code may use the <CODE>f256jr.h</CODE> header file.</P>


<H2><A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">F256jr-specific functions</A>
</H2>


<P>The functions listed below are special for the F256jr. See the 
<A HREF="smellybutt.html">non-existent function reference</A> for declaration and usage.</P>
<P>
<UL>
<LI>TBD1</LI>
<LI>TBD2</LI>
</UL>
</P>


<H2><A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">F256jr-specific accelerator functions</A>
</H2>


<P>There are no accelerator functions for the F256jr, largely due to the fact that no accelerators exist for the machine.</P>


<H2><A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">F256 Microkernel functions</A>
</H2>


<P>If you are targeting Gadget's microkernel, you can access the functions via the kernel.h file. You must use the f256jr_with_kernel.lib instead of the f256jr.lib to take advantage of kernel.h. (still in heavy development, documentation to follow)</P>
<P>
<UL>
<LI><A HREF="#f256jr_open">F256jr open</A></LI>
<LI><A HREF="#f256jr_read">F256jr read</A></LI>
<LI><A HREF="#f256jr_write">F256jr write</A></LI>
<LI><A HREF="#f256jr_close">F256jr close</A></LI>
</UL>
</P>


<H2><A NAME="f256jr_open"></A> <A NAME="ss4.3.1">4.3.1</A> <A HREF="#toc3.55">F256jr open</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Open a file from disk</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#kernel.h">kernel.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned char __fastcall__ open(const char *fname, unsigned char mode);</CODE></P>
<DT><B>Description</B><DD>
<P>This function attempts to open a file at the filename passed, and return a handle to that file. Pass O_RDONLY for read-only mode, or O_WRONLY for write-only mode. If it succeeds, it will return a non-zero number. If opening in read-only mode, and the file does not exist, 0 will be returned. You can optionally pass "a:" (IEC device 1), "b:" (IEC device 2), or "c:" (SD card) as a preface to the filename. If no device identifier is passed, the kernel will check all attached devices for a match.</P>
<DT><B>Notes</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>f256jr with kernel</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#f256jr_read">F256jr read</A>,
<A HREF="#f256jr_write">F256jr write</A>,
<A HREF="#f256jr_close">F256jr close</A>,
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>



<H2><A NAME="f256jr_read"></A> <A NAME="ss4.3.1">4.3.2</A> <A HREF="#toc3.55">F256jr read</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Read data from a file on disk</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#kernel.h">kernel.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned int __fastcall__ read(unsigned char fd, void *buf, unsigned int nbytes);</CODE></P>
<DT><B>Description</B><DD>
<P>This function attempts to read data from the file corresponding to the file descriptor passed (fd), into the buffer passed. It will read up to nbytes of data, and return the number of bytes read. It is not guaranteed to read all the bytes requested: you must call this function as many times as needed until all desired bytes have been read. If no more bytes are available, it will return EOF (0). On any error, it will return a negative number. The file must have been opened for reading before calling this function.</P>
<DT><B>Notes</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>f256jr with kernel</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#f256jr_open">F256jr open</A>,
<A HREF="#f256jr_write">F256jr write</A>,
<A HREF="#f256jr_close">F256jr close</A>,
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>




<H2><A NAME="f256jr_write"></A> <A NAME="ss4.3.3">4.3.3</A> <A HREF="#toc3.55">F256jr write</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Write data to a file on disk</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#kernel.h">kernel.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>unsigned int __fastcall__ write(unsigned char fd, void *buf, unsigned int nbytes);</CODE></P>
<DT><B>Description</B><DD>
<P>This function attempts to write data to the file corresponding to the file descriptor passed (fd), from the buffer passed. It will write up to nbytes of data, and return the number of bytes written. It will write out all bytes requested (except in the case of error): you do NOT need to call this function in a loop. On any error, it will return a negative number. The file must have been opened for writing before calling this function.</P>
<DT><B>Notes</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>f256jr with kernel</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#f256jr_open">F256jr open</A>,
<A HREF="#f256jr_read">F256jr read</A>,
<A HREF="#f256jr_close">F256jr close</A>,
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>




<H2><A NAME="f256jr_close"></A> <A NAME="ss4.3.4">4.3.4</A> <A HREF="#toc3.55">F256jr close</A>
</H2>


<P>
<BLOCKQUOTE>
<DL>
<DT><B>Function</B><DD>
<P>Close a previously opened file on disk</P>
<DT><B>Header</B><DD>
<P><CODE>
<A HREF="#kernel.h">kernel.h</A></CODE></P>
<DT><B>Declaration</B><DD>
<P><CODE>void __fastcall__ close(unsigned char fd);</CODE></P>
<DT><B>Description</B><DD>
<P>This function attempts to close the file corresponding to the file descriptor passed (fd). If you fail to call this after opening a file, you may cause permanent data damage!</P>
<DT><B>Notes</B><DD>
<P>
<UL>
<LI>The function is only available as fastcall function, so it may
only be used in presence of a prototype.</LI>
</UL>
</P>
<DT><B>Availability</B><DD>
<P>f256jr with kernel</P>
<DT><B>See also</B><DD>
<P>
<A HREF="#f256jr_open">F256jr open</A>,
<A HREF="#f256jr_read">F256jr read</A>,
<A HREF="#f256jr_write">F256jr write</A>,
<DT><B>Example</B><DD>
<P>None.</P>
</DL>
</BLOCKQUOTE>
</P>



<p>TODO: <br/>
char GETIN(void); <br/>
void YIELD(void); <br/>
void PLOT(uint8_t x, uint8_t y, uint8_t c); <br/>
</p>



<H2><A NAME="ss4.5">4.5</A> <A HREF="#toc4.5">Hardware access</A>
</H2>


<P>The following pseudo variables declared in the <CODE>f256jr.h</CODE> header file do
allow access to hardware located in the address space. Some variables are
structures, accessing the struct fields will access the chip registers.</P>
<P>
<DL>

<DT><B><CODE>none yet -- stay tuned!</CODE></B><DD>
<P>May add items as necessary. For now, reference the macros defined.</P>

</DL>
</P>




<H2><A NAME="s5">5.</A> <A HREF="#toc5">Loadable drivers</A></H2>


<P>The names in the parentheses denote the symbols to be used for static linking of the drivers.</P>


<H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Graphics drivers</A>
</H2>


<P>There are no graphics drivers yet for the F256jr, but adapting existing drivers would not be complicated. Volunteers wanted!</P>
<P>
<DL>

<DT><B><CODE>f256jr.tgi (f256jr_tgi)</CODE></B><DD>
<P>This driver features a resolution of 320&times;200 with 256 colors and an
adjustable palette (that means that the two colors can be chosen out of a
palette of the 16M colors). This driver does not exist. Perhaps you would like to write it? </P>

</DL>
</P>

<H2><A NAME="ss5.2">5.2</A> <A HREF="#toc5.2">Extended memory drivers</A>
</H2>


<P>There are no extended memory drivers for the F256jr, because they are not needed. It is not necessary to COPY data from "extended" memory to 65C02 memory: you can simply map it into 65C02 space using the MMU. This is 8.25 million times faster, and saves you the 300-600 bytes the driver would take up. </P>


<H2><A NAME="ss5.3">5.3</A> <A HREF="#toc5.3">Joystick drivers</A>
</H2>


<P>The default drivers, <CODE>joy_stddrv (joy_static_stddrv)</CODE>, point to <CODE>f256jr-stdjoy.joy (f256jr_stdjoy_joy)</CODE>. Or they would, if anyone had written them. TODO!</P>
<P>
<DL>

<DT><B><CODE>f256jr-stdjoy.joy (f256jr_stdjoy_joy)</CODE></B><DD>
<P>Supports up to two joysticks connected to the standard joysticks ports of the F256jr. Note: this driver exists only in your head.</P>
</DL>
</P>




<H2><A NAME="ss5.4">5.4</A> <A HREF="#toc5.4">Mouse drivers</A>
</H2>


<P>The default drivers, <CODE>mouse_stddrv (mouse_static_stddrv)</CODE>, point to <CODE>f256jr-ps2.mou (f256jr_ps2_mou)</CODE>. Just kidding. They don't, because I didn't write any mouse drivers. I have a JR, not a K, so I need the ps/2 port for you know... a keyboard. Let's come back to this when the F256Ks ship.</P>
<P>
<DL>

<DT><B><CODE>f256jr-ps2.mou (f256jr_ps2_mou)</CODE></B><DD>
<P>Supports a standard mouse connected to the ps/2 port of the F256jr.</P>

<DT><B><CODE>f256jr-joy-1350.mou (f256jr_joy_1350_mou)</CODE></B><DD>
<P>Supports a mouse emulated by a standard joystick, e.g. 1350 mouse, in port
#1 of the F256jr. This is an interesting concept... should we do this? Anyone have a 1350 mouse? </P>

</DL>
</P>



<H2><A NAME="ss5.5">5.5</A> <A HREF="#toc5.5">RS232 device drivers</A>
</H2>


<P>There are no serial drivers yet. Who wants to write one?</P>

</DL>
</P>




<H2><A NAME="s6">6.</A> <A HREF="#toc6">Limitations</A></H2>




<H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Nothing worth mentioning</A>
</H2>


<P>I'm sure people will think of something once they start using this library...</P>



<H2><A NAME="s7">7.</A> <A HREF="#toc7">Other hints</A></H2>




<H2><A NAME="ss7.1">7.1</A> <A HREF="#toc7.1">Passing arguments to the program</A>
</H2>


<P>This is what the C128 library for cc65 says: Command-line arguments can be passed to <CODE>main()</CODE>. Since this is not
supported directly by BASIC, the following syntax was chosen:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    RUN:REM ARG1 " ARG2 IS QUOTED" ARG3 "" ARG5
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Should we try to do something like that for the F256jr? Let's see how things go with SuperBASIC...
</P>
<P>
<OL>
<LI>Arguments are separated by spaces.</LI>
<LI>Arguments may be quoted.</LI>
<LI>Leading and trailing spaces around an argument are ignored. Spaces within
a quoted argument are allowed.</LI>
<LI>The first argument passed to <CODE>main()</CODE> is the program name.</LI>
<LI>A maximum number of 10 arguments (including the program name) are
supported.</LI>
</OL>
</P>


<H2><A NAME="ss7.2">7.2</A> <A HREF="#toc7.2">Program return code</A>
</H2>


<P>The program return code (low byte) is passed back to BASIC by use of the
<CODE>ST</CODE> variable. TODO.</P>


<H2><A NAME="ss7.3">7.3</A> <A HREF="#toc7.3">Interrupts</A>
</H2>


<P>The runtime for the F256jr uses routines marked as <CODE>.INTERRUPTOR</CODE> for
interrupt handlers. Such routines must be written as simple machine language
subroutines and will be called automatically by the interrupt handler code
when they are linked into a program. See the discussion of the <CODE>.CONDES</CODE>
feature in the 
<A HREF="ca65.html">assembler manual</A>. NOTE: the library does not yet have support for interrupts.</P>



<H2><A NAME="s8">8.</A> <A HREF="#toc8">License</A></H2>


<P>This software is provided 'as-is', without any expressed or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.</P>
<P>Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:</P>
<P>
<OL>
<LI>  The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.</LI>
<LI>  Altered source versions must be plainly marked as such, and must not
be misrepresented as being the original software.</LI>
<LI>  This notice may not be removed or altered from any source
distribution.</LI>
</OL>
</P>

</BODY>
</HTML>
